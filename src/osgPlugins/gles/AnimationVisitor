/* -*-c++-*- OpenSceneGraph - Copyright (C) Cedric Pinson
 *
 * This application is open source and may be redistributed and/or modified
 * freely and without restriction, both in commercial and non commercial
 * applications, as long as this copyright notice is maintained.
 *
 * This application is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef ANIMATION_VISITOR
#define ANIMATION_VISITOR

#include <osgUtil/UpdateVisitor>
#include <osgAnimation/RigTransformHardware>
#include <osgAnimation/RigGeometry>

#include "GeometryUniqueVisitor"
#include <osg/ValueObject>
#include <osg/Array>

#include <algorithm>
#include <utility>
#include <set>
#include <map>
#include <sstream>


struct sort_weights {
    bool operator()(const std::pair<unsigned int, float> &left, const std::pair<unsigned int, float> &right) {
        return left.second > right.second;
    }
};


// the idea is to create true Geometry if skeleton with RigGeometry
class AnimationVisitor : public osgUtil::UpdateVisitor
{
public:
    AnimationVisitor():
        _logger("AnimationVisitor::apply(..)")
    {
        setFrameStamp(new osg::FrameStamp());
    }

    void apply(osg::Drawable& drawable) {
        // skip drawables already processed
        if (isProcessed(drawable)) {
            return;
        }

        apply(drawable.asGeometry());

        setProcessed(drawable);
    }

    void apply(osg::Geometry* geometry) {
        osgAnimation::RigGeometry* rig = dynamic_cast<osgAnimation::RigGeometry*>(geometry);
        if(rig) {
            apply(*rig);
        }
    }

    void apply(osgAnimation::RigGeometry& geometry) {
        // find skeleton
        osgAnimation::UpdateRigGeometry rigUpdater;
        rigUpdater.update(0, &geometry);

        osgAnimation::RigTransformHardware rth;
        rth(geometry);
        std::vector< std::vector< std::pair<unsigned int, float> > > vertexBoneWeights(geometry.getVertexArray()->getNumElements());

        // collect all bone/weight pairs for *all* vertices
        for(unsigned int i = 0 ; i < rth.getNumVertexAttrib() ; ++ i) {
            osg::Vec4Array* weights = dynamic_cast<osg::Vec4Array*>(rth.getVertexAttrib(i));
            for(unsigned int k = 0 ; k < weights->getNumElements() ; ++ k) {
                vertexBoneWeights[k].push_back(std::pair<unsigned int, float>((*weights)[k][0], (*weights)[k][1]));
                vertexBoneWeights[k].push_back(std::pair<unsigned int, float>((*weights)[k][2], (*weights)[k][3]));
            }
        }

        osg::ref_ptr<osg::Vec4uiArray> bones = new osg::Vec4uiArray;
        osg::ref_ptr<osg::Vec4Array> weights = new osg::Vec4Array;

        // for each vertex a partial sort to keep only n max weights (hardcoded to 4)
        for(unsigned int i = 0 ; i < vertexBoneWeights.size() ; ++ i) {
            std::vector< std::pair<unsigned int, float> > maxVertexBoneWeight(4);
            std::partial_sort_copy(vertexBoneWeights[i].begin(), vertexBoneWeights[i].end(),
                                   maxVertexBoneWeight.begin(), maxVertexBoneWeight.end(),
                                   sort_weights());

            osg::Vec4 vertexWeights;
            osg::Vec4ui vertexBones;
            for(unsigned int j = 0 ; j < 4 ; ++ j) {
                vertexBones[j] = maxVertexBoneWeight[j].first;
                vertexWeights[j] = maxVertexBoneWeight[j].second;
            }

            bones->push_back(vertexBones);
            weights->push_back(vertexWeights);
        }

        std::map<unsigned int, unsigned int> geometryBoneIndices = remapGeometryBones(*bones);
        applyBoneIndicesRemap(*bones, geometryBoneIndices);
        serializeBonesUserValues(*bones, geometryBoneIndices, rth.getBoneNameToPalette());

        bones->setUserValue("bones", true);
        weights->setUserValue("weights", true);

        geometry.setVertexAttribArray(geometry.getNumVertexAttribArrays(), bones, osg::Array::BIND_PER_VERTEX);
        geometry.setVertexAttribArray(geometry.getNumVertexAttribArrays(), weights, osg::Array::BIND_PER_VERTEX);
    }

protected:
    std::map<unsigned int, unsigned int> remapGeometryBones(const osg::Vec4uiArray& bones) {
        std::map<unsigned int, unsigned int> remap;
        for(unsigned int i = 0 ; i < bones.getNumElements() ; ++ i) {
            for(unsigned int j = 0 ; j < 4 ; ++ j) {
                if(remap.find(bones[i][j]) == remap.end()) {
                    remap[bones[i][j]] = remap.size() - 1;
                }
            }
        }
        return remap;
    }

    void applyBoneIndicesRemap(osg::Vec4uiArray& bones, const std::map<unsigned int, unsigned int>& remap) {
        for(unsigned int i = 0 ; i < bones.getNumElements() ; ++ i) {
            std::map<unsigned int, unsigned int>::const_iterator x = remap.find(bones[i][0]),
                                                                 y = remap.find(bones[i][1]),
                                                                 z = remap.find(bones[i][2]),
                                                                 w = remap.find(bones[i][3]);
            bones[i] = osg::Vec4ui(x->second,
                                   y->second,
                                   z->second,
                                   w->second);
        }
    }


    void serializeBonesUserValues(osg::Vec4uiArray& bones, const std::map<unsigned int, unsigned int>& oldIndexToNewIndex,
                                  const osgAnimation::RigTransformHardware::BoneNamePaletteIndex& boneNamePaletteIndex) {

        // map 'global' palette index to bone name
        std::map<unsigned int, std::string> oldIndexToBoneName;
        for(osgAnimation::RigTransformHardware::BoneNamePaletteIndex::const_iterator it = boneNamePaletteIndex.begin() ;
            it != boneNamePaletteIndex.end() ; ++ it) {
            oldIndexToBoneName[static_cast<unsigned int>(it->second)] = it->first;
        }

        // serialize geometry 'palette index' => 'bone name' with user value using animationBone_ as
        // name prefix
        for(std::map<unsigned int, unsigned int>::const_iterator it = oldIndexToNewIndex.begin() ; it != oldIndexToNewIndex.end() ; ++ it) {
            std::ostringstream oss;
            oss << "animationBone_" << it->second;
            bones.setUserValue(oss.str(), oldIndexToBoneName[it->first]);
        }
    }

    bool isProcessed(osg::Drawable& node) {
        return _processed.find(&node) != _processed.end();
    }

    void setProcessed(osg::Drawable& node) {
        _processed.insert(&node);
    }

    std::set<osg::Drawable*> _processed;
    StatLogger _logger;
};

#endif
