/* -*-c++-*- OpenSceneGraph - Copyright (C) Cedric Pinson
 *
 * This application is open source and may be redistributed and/or modified
 * freely and without restriction, both in commercial and non commercial
 * applications, as long as this copyright notice is maintained.
 *
 * This application is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef ANIMATION_VISITOR
#define ANIMATION_VISITOR

#include <osgUtil/UpdateVisitor>
#include <osgAnimation/RigTransformHardware>
#include <osgAnimation/RigGeometry>

#include "GeometryUniqueVisitor"
#include <osg/ValueObject>
#include <osg/Array>

#include <algorithm>
#include <utility>
#include <set>

struct sort_weights {
    bool operator()(const std::pair<unsigned int, float> &left, const std::pair<unsigned int, float> &right) {
        return left.second > right.second;
    }
};


// the idea is to create true Geometry if skeleton with RigGeometry
class AnimationVisitor : public osgUtil::UpdateVisitor
{
public:
    AnimationVisitor():
        _logger("AnimationVisitor::apply(..)")
    {
        setFrameStamp(new osg::FrameStamp());
    }

    void apply(osg::Drawable& drawable) {
        // skip drawables already processed
        if (isProcessed(drawable)) {
            return;
        }

        apply(drawable.asGeometry());

        setProcessed(drawable);
    }

    void apply(osg::Geometry* geometry) {
        osgAnimation::RigGeometry* rig = dynamic_cast<osgAnimation::RigGeometry*>(geometry);
        if(rig) {
            apply(*rig);
        }
    }

    void apply(osgAnimation::RigGeometry& geometry) {
        // find skeleton
        osgAnimation::UpdateRigGeometry rigUpdater;
        rigUpdater.update(0, &geometry);

        osgAnimation::RigTransformHardware rth;
        rth(geometry);
        std::vector< std::vector< std::pair<unsigned int, float> > > vertexBoneWeights(geometry.getVertexArray()->getNumElements());

        // collect all bone/weight pairs for *all* vertices
        for(unsigned int i = 0 ; i < rth.getNumVertexAttrib() ; ++ i) {
            osg::Vec4Array* weights = dynamic_cast<osg::Vec4Array*>(rth.getVertexAttrib(i));
            for(unsigned int k = 0 ; k < weights->getNumElements() ; ++ k) {
                vertexBoneWeights[k].push_back(std::pair<unsigned int, float>((*weights)[k][0], (*weights)[k][1]));
                vertexBoneWeights[k].push_back(std::pair<unsigned int, float>((*weights)[k][2], (*weights)[k][3]));
            }
        }

        osg::ref_ptr<osg::Vec4uiArray> bones = new osg::Vec4uiArray;
        osg::ref_ptr<osg::Vec4Array> weights = new osg::Vec4Array;

        // for each vertex a partial sort to keep only n max weights (hardcoded to 4)
        for(unsigned int i = 0 ; i < vertexBoneWeights.size() ; ++ i) {
            std::vector< std::pair<unsigned int, float> > maxVertexBoneWeight(4);
            std::partial_sort_copy(vertexBoneWeights[i].begin(), vertexBoneWeights[i].end(),
                                   maxVertexBoneWeight.begin(), maxVertexBoneWeight.end(),
                                   sort_weights());

            osg::Vec4 vertexWeights;
            osg::Vec4ui vertexBones;
            for(unsigned int j = 0 ; j < 4 ; ++ j) {
                vertexBones[j] = maxVertexBoneWeight[j].first;
                vertexWeights[j] = maxVertexBoneWeight[j].second;
            }

            bones->push_back(vertexBones);
            weights->push_back(vertexWeights);
        }
        bones->setUserValue("bones", true);
        weights->setUserValue("weights", true);

        geometry.setVertexAttribArray(geometry.getNumVertexAttribArrays(), bones, osg::Array::BIND_PER_VERTEX);
        geometry.setVertexAttribArray(geometry.getNumVertexAttribArrays(), weights, osg::Array::BIND_PER_VERTEX);
    }

protected:
    bool isProcessed(osg::Drawable& node) {
        return _processed.find(&node) != _processed.end();
    }

    void setProcessed(osg::Drawable& node) {
        _processed.insert(&node);
    }

    std::set<osg::Drawable*> _processed;
    StatLogger _logger;
};

#endif
