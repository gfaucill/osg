/* -*-c++-*- OpenSceneGraph - Copyright (C) 2012 Cedric Pinson  */
#ifndef WRITE_VISITOR_H
#define WRITE_VISITOR_H

#include <osg/Image>
#include <osg/Notify>
#include <osg/Geode>
#include <osg/Geometry>
#include <osg/GL>
#include <osg/Version>
#include <osg/Endian>
#include <osg/Projection>
#include <osg/MatrixTransform>
#include <osg/PagedLOD>
#include <osg/PositionAttitudeTransform>
#include <osgAnimation/BasicAnimationManager>
#include <osgAnimation/Skeleton>
#include <osg/LightSource>
#include <osg/CullFace>
#include <osg/Material>
#include <osg/BlendColor>
#include <osg/BlendFunc>
#include <osg/ValueObject>
#include <osg/Array>

#include <osgAnimation/RigGeometry>
#include <osgAnimation/Bone>
#include <osgAnimation/UpdateBone>

#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>

#include "JSON_Objects"
#include "Animation"
#include "json_stream"


#define WRITER_VERSION 7


osg::Array* getTangentSpaceArray(osg::Geometry& geometry);
void translateObject(JSONObject* json, osg::Object* osg);
void getStringifiedUserValue(osg::Object* o, std::string& name, std::string& value);
template<typename T>
bool getStringifiedUserValue(osg::Object* o, std::string& name, std::string& value);


class WriteVisitor : public osg::NodeVisitor
{
public:
    typedef std::vector<osg::ref_ptr<osg::StateSet> > StateSetStack;

    std::map<osg::ref_ptr<osg::Object>, osg::ref_ptr<JSONObject> > _maps;
    std::vector<osg::ref_ptr<JSONObject> > _parents;
    osg::ref_ptr<JSONObject> _root;
    StateSetStack _stateset;
    std::string _baseName;
    bool _useExternalBinaryArray;
    bool _mergeAllBinaryFiles;
    bool _inlineImages;
    bool _varint;
    int _maxTextureDimension;
    std::map<std::string, std::string> _specificBuffers;
    std::map<std::string, std::ofstream*> _buffers;

    std::ofstream& getBufferFile(const std::string& name) {
        if(_buffers.find(name) == _buffers.end()) {
            _buffers[name] = new std::ofstream(name.c_str(), std::ios::binary);
        }
        return *_buffers[name];
    }

    WriteVisitor(): osg::NodeVisitor(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN) {
        _mergeAllBinaryFiles = false;
        _useExternalBinaryArray = false;
        _inlineImages = false;
        _maxTextureDimension = 0;
        _varint = false;
    }

    ~WriteVisitor() {
        for(std::map<std::string, std::ofstream*>::iterator buffer = _buffers.begin() ;
            buffer != _buffers.end() ; ++ buffer) {
            delete buffer->second;
        }
    }

    std::string getBinaryFilename(const std::string& buffer = "") const {
        std::string suffix;
        std::map<std::string, std::string>::const_iterator it_buffer = _specificBuffers.find(buffer);
        if(it_buffer != _specificBuffers.end()) {
            suffix = "_" + it_buffer->second;
        }
        return std::string(_baseName) + suffix + ".bin";
    }

    void closeBuffers() {
        for(std::map<std::string, std::ofstream*>::iterator buffer = _buffers.begin() ;
            buffer != _buffers.end() ; ++ buffer) {
            buffer->second->close();
        }
    }

    unsigned int getBuffersSize() const {
        unsigned int size = 0;
        for(std::map<std::string, std::ofstream*>::const_iterator buffer = _buffers.begin() ;
            buffer != _buffers.end() ; ++ buffer) {
            size += buffer->second->tellp();
        }
        return size;
    }

    void write(json_stream& str) {
        osg::ref_ptr<JSONObject> o = new JSONObject();
        o->getMaps()["Version"] = new JSONValue<int>(WRITER_VERSION);
        o->getMaps()["Generator"] = new JSONValue<std::string>("OpenSceneGraph " + std::string(osgGetVersion()) );
        o->getMaps()["osg.Node"] = _root.get();
        o->write(str, *this);
        if (_mergeAllBinaryFiles) {
            closeBuffers();
            unsigned int size = getBuffersSize();
            osg::notify(osg::NOTICE) << "Use a merged binary file ";
            if (size/1024.0 < 1.0) {
                osg::notify(osg::NOTICE) << size << " bytes" << std::endl;
            } else if (size/(1024.0*1024.0) < 1.0) {
                osg::notify(osg::NOTICE) << size/1024.0 << " kb" << std::endl;
            } else {
                osg::notify(osg::NOTICE) << size/(1024.0*1024.0) << " mb" << std::endl;
            }
        }
    }

    void error() {
        throw "Error occur";
    }

    void setBufferName(JSONObject *json, osg::Object* parent=0, osg::Object* object=0) const {
        if(!_mergeAllBinaryFiles || _specificBuffers.empty())
            return;

        // try to fetch buffer name for object
        std::string bufferName = getBufferName(object);
        std::string defaultBufferName = getBinaryFilename();
        std::string jsonBufferName = json->getBufferName();

        if(bufferName == defaultBufferName) {
            // in case none is set, fallback to parent buffer name
            bufferName = getBufferName(parent);
        }
        // if the buffer is shared we will always favor dumping it in the default
        // buffer and otherwise we keep the first buffer name set.
        if(!jsonBufferName.empty()) {
            if(jsonBufferName != defaultBufferName && bufferName == defaultBufferName) {
                json->setBufferName(defaultBufferName);
            }
        }
        else {
            json->setBufferName(bufferName);
        }
    }

    std::string getBufferName(osg::Object* object) const {
        std::string name("");
        bool isSpecific = false;
        if(object) {
            for(std::map<std::string, std::string>::const_iterator it_flag = _specificBuffers.begin() ;
                it_flag != _specificBuffers.end() ; ++ it_flag) {
                std::cout << "looking for user value: " << it_flag->first << std::endl;
                if(object->getUserValue(it_flag->first, isSpecific) && isSpecific) {
                    name = it_flag->first;
                    break;
                }
            }
        }
        return getBinaryFilename(name);
    }

    JSONObject* createJSONPagedLOD(osg::PagedLOD* plod);
    JSONObject* createJSONStateSet(osg::StateSet* ss);
    JSONObject* createJSONTexture(osg::Texture* sa);
    JSONObject* createJSONMaterial(osg::Material* sa);
    JSONObject* createJSONLight(osg::Light* sa);
    JSONObject* createJSONCullFace(osg::CullFace* sa);
    JSONObject* createJSONBlendColor(osg::BlendColor* sa);
    JSONObject* createJSONBlendFunc(osg::BlendFunc* sa);

    JSONObject* createJSONBufferArray(osg::Array* array, osg::Object* parent = 0);
    JSONObject* createJSONDrawElements(osg::DrawArrays* drawArray, osg::Object* parent = 0);

    JSONObject* createJSONDrawElementsUInt(osg::DrawElementsUInt* de, osg::Object* parent = 0);
    JSONObject* createJSONDrawElementsUShort(osg::DrawElementsUShort* de, osg::Object* parent = 0);
    JSONObject* createJSONDrawElementsUByte(osg::DrawElementsUByte* de, osg::Object* parent = 0);

    JSONObject* createJSONDrawArray(osg::DrawArrays* drawArray, osg::Object* parent = 0);
    JSONObject* createJSONDrawArrayLengths(osg::DrawArrayLengths* drawArray, osg::Object* parent = 0);

    JSONObject* createJSONGeometry(osg::Geometry* geom);
    JSONObject* createJSONRigGeometry(osgAnimation::RigGeometry* rGeom);

    JSONObject* getParent() {
        if (_parents.empty()) {
            _root = new JSONObject;
            _parents.push_back(_root.get());
        }
        return _parents.back().get();
    }

    void initJsonObjectFromNode(osg::Node& node, JSONObject& json) {
        translateObject(&json, &node);
    }


    void createJSONStateSet(JSONObject* json, osg::StateSet* ss) {
        JSONObject* json_stateset = createJSONStateSet(ss);
        if (json_stateset) {
            JSONObject* obj = new JSONObject;
            obj->getMaps()["osg.StateSet"] = json_stateset;
            json->getMaps()["StateSet"] = obj;

        }
    }
    void createJSONStateSet(osg::Node& node, JSONObject* json) {
        if (node.getStateSet()) {
            createJSONStateSet(json, node.getStateSet());
        }
    }

    void applyCallback(osg::Node& node, JSONObject* json) {
        JSONArray* updateCallbacks = new JSONArray;
        osg::Callback* nc = node.getUpdateCallback();
        while (nc) {
            osgAnimation::BasicAnimationManager* am = dynamic_cast<osgAnimation::BasicAnimationManager*>(nc);
            if (am) {
                JSONArray* array = new JSONArray;
                JSONObject* bam = new JSONObject;
                translateObject(bam, am);
                bam->getMaps()["Animations"] = array;

                JSONObject* nodeCallbackObject = new JSONObject;
                nodeCallbackObject->getMaps()["osgAnimation.BasicAnimationManager"] = bam;
                updateCallbacks->getArray().push_back(nodeCallbackObject);

                for ( unsigned int i = 0; i < am->getAnimationList().size(); i++) {
                    osgAnimation::Animation* animation = am->getAnimationList()[i].get();
                    osg::ref_ptr<JSONObject> jsonAnim = createJSONAnimation(animation, this);
                    if (jsonAnim) {
                        translateObject(jsonAnim.get(), animation);
                        JSONObject* obj = new JSONObject;
                        obj->getMaps()["osgAnimation.Animation"] = jsonAnim;
                        array->getArray().push_back(obj);
                    }
                }
            } else {
                osgAnimation::UpdateBone* upBone = dynamic_cast<osgAnimation::UpdateBone*>(nc);
                if (upBone) {
                    osg::ref_ptr<JSONObject> jsonCallback = createJSONUpdateMatrixTransform(*upBone, this);
                    if (jsonCallback.valid()) {
                        osg::ref_ptr<JSONObject> jsonObject = new JSONObject;
                        jsonObject->getMaps()["osgAnimation.UpdateBone"] = jsonCallback;
                        updateCallbacks->getArray().push_back(jsonObject);
                    }
                } else {
                    osgAnimation::UpdateMatrixTransform* updateMT = dynamic_cast<osgAnimation::UpdateMatrixTransform*>(nc);
                    if (updateMT) {
                        osg::ref_ptr<JSONObject> jsonCallback = createJSONUpdateMatrixTransform(*updateMT, this);
                        if (jsonCallback.valid()) {
                            osg::ref_ptr<JSONObject> jsonObject = new JSONObject;
                            jsonObject->getMaps()["osgAnimation.UpdateMatrixTransform"] = jsonCallback;
                            updateCallbacks->getArray().push_back(jsonObject);
                        }
                    } else {
                        osgAnimation::Skeleton::UpdateSkeleton* updateSk = dynamic_cast<osgAnimation::Skeleton::UpdateSkeleton*>(nc);
                        if (updateSk) {
                            osg::ref_ptr<JSONObject> json = new JSONNode;
                            osg::ref_ptr<JSONObject> jsonObject = new JSONObject;
                            json->addUniqueID();
                            _maps[&node] = json;
                            jsonObject->getMaps()["osgAnimation.UpdateSkeleton"] = json;
                            updateCallbacks->getArray().push_back(jsonObject);
                        }
                    }
                }
            }
            nc = nc->getNestedCallback();
        }

        if (!updateCallbacks->getArray().empty()) {
            json->getMaps()["UpdateCallbacks"] = updateCallbacks;
        }
    }

    void apply(osg::Drawable& drw) {
        osgAnimation::RigGeometry * rGeom = dynamic_cast<osgAnimation::RigGeometry*>(&drw);
        if (rGeom) {
            JSONObject* json = createJSONRigGeometry(rGeom);
            JSONObject* parent = getParent();
            parent->addChild("osgAnimation.RigGeometry", json);
        } else {
            osg::Geometry* geom = dynamic_cast<osg::Geometry*>(&drw);
            if (geom) {
                JSONObject* json = createJSONGeometry(geom);
                JSONObject* parent = getParent();
                parent->addChild("osg.Geometry", json);
           }
        }
    }

    void apply(osg::Geode& node) {

        JSONObject* parent = getParent();
        if (_maps.find(&node) != _maps.end()) {
            parent->addChild("osg.Node", _maps[&node]->getShadowObject());
            return;
        }

        osg::ref_ptr<JSONObject> json = new JSONNode;
        json->addUniqueID();
        _maps[&node] = json;

        applyCallback(node, json.get());
        createJSONStateSet(node, json.get());

        parent->addChild("osg.Node", json.get());
        initJsonObjectFromNode(node, *json);
        _parents.push_back(json);
        for (unsigned int i = 0; i < node.getNumDrawables(); ++i) {
            if (node.getDrawable(i))
                apply(*node.getDrawable(i));
        }
        _parents.pop_back();
    }

    void apply(osg::Group& node) {

        JSONObject* parent = getParent();
        if (_maps.find(&node) != _maps.end()) {
            parent->addChild("osg.Node", _maps[&node]->getShadowObject());
            return;
        }

        osg::ref_ptr<JSONObject> json = new JSONNode;
        json->addUniqueID();
        _maps[&node] = json;
        parent->addChild("osg.Node", json.get());

        applyCallback(node, json.get());
        createJSONStateSet(node, json.get());

        initJsonObjectFromNode(node, *json);

        _parents.push_back(json);
        traverse(node);
        _parents.pop_back();
    }

    void apply(osg::PagedLOD& node)
    {
        JSONObject* parent = getParent();
        if (_maps.find(&node) != _maps.end()) {
            parent->addChild("osg.PagedLOD", _maps[&node]->getShadowObject());
            return;
        }

        osg::ref_ptr<JSONObject> json = createJSONPagedLOD(&node);
        json->addUniqueID();
        _maps[&node] = json;
        parent->addChild("osg.PagedLOD", json.get());


        applyCallback(node, json.get());


        createJSONStateSet(node, json.get());

        initJsonObjectFromNode(node, *json);
        _parents.push_back(json);
        traverse(node);
        _parents.pop_back();
    }

    void apply(osg::LightSource& node) {

        JSONObject* parent = getParent();
        if (_maps.find(&node) != _maps.end()) {
            parent->addChild("osg.LightSource", _maps[&node]->getShadowObject());
            return;
        }

        osg::ref_ptr<JSONObject> json = new JSONNode;
        json->addUniqueID();
        _maps[&node] = json;

        applyCallback(node, json.get());
        createJSONStateSet(node, json.get());

        parent->addChild("osg.LightSource", json.get());

        initJsonObjectFromNode(node, *json);

        if (node.getLight()) {
            JSONObject* obj = new JSONObject;
            obj->getMaps()["osg.Light"] = createJSONLight(node.getLight());
            json->getMaps()["Light"] = obj;
        }

        _parents.push_back(json);
        traverse(node);
        _parents.pop_back();
    }

    void apply(osg::Projection& node) {
        JSONObject* parent = getParent();
        if (_maps.find(&node) != _maps.end()) {
            parent->addChild("osg.Projection", _maps[&node]->getShadowObject());
            return;
        }

        osg::ref_ptr<JSONObject> json = new JSONNode;
        json->addUniqueID();
        _maps[&node] = json;

        applyCallback(node, json.get());
        createJSONStateSet(node, json.get());

        parent->addChild("osg.Projection", json.get());

        initJsonObjectFromNode(node, *json);
        json->getMaps()["Matrix"] = new JSONMatrix(node.getMatrix());
        _parents.push_back(json);
        traverse(node);
        _parents.pop_back();
    }

    void applyCommonMatrixTransform(const char * jsClassName, osg::ref_ptr<JSONObject> &json, osg::MatrixTransform &node, JSONObject* parent) {
        json->addUniqueID();
        _maps[&node] = json;

        applyCallback(node, json.get());
        createJSONStateSet(node, json.get());

        parent->addChild(jsClassName, json.get());

        initJsonObjectFromNode(node, *json);
        json->getMaps()["Matrix"] = new JSONMatrix(node.getMatrix());
    }

    void apply(osg::MatrixTransform& node) {
        if (dynamic_cast<osgAnimation::Skeleton*>(&node)) {
           apply(static_cast<osgAnimation::Skeleton&>(node));
           return;
        }
        if (dynamic_cast<osgAnimation::Bone*>(&node)) {
            apply(static_cast<osgAnimation::Bone&>(node));
            return;
        }

        JSONObject* parent = getParent();
        if (_maps.find(&node) != _maps.end()) {
            parent->addChild("osg.MatrixTransform", _maps[&node]->getShadowObject());
            return;
        }
        osg::ref_ptr<JSONObject> json = new JSONNode;
        json->addUniqueID();
        _maps[&node] = json;

        applyCallback(node, json.get());
        createJSONStateSet(node, json.get());

        parent->addChild("osg.MatrixTransform", json.get());

        initJsonObjectFromNode(node, *json);
        json->getMaps()["Matrix"] = new JSONMatrix(node.getMatrix());

        _parents.push_back(json);
        traverse(node);
        _parents.pop_back();

    }

    void apply(osgAnimation::Skeleton& node) {
        JSONObject* parent = getParent();
        if (_maps.find(&node) != _maps.end()) {
            parent->addChild("osgAnimation.Skeleton", _maps[&node]->getShadowObject());
            return;
        }
        osg::ref_ptr<JSONObject> json = new JSONNode;
        applyCommonMatrixTransform("osgAnimation.Skeleton", json, node, parent);
        _parents.push_back(json);
        traverse(node);
        _parents.pop_back();
    }

    void apply(osgAnimation::Bone &node) {
        JSONObject* parent = getParent();
        if (_maps.find(&node) != _maps.end()) {
            parent->addChild("osgAnimation.Bone", _maps[&node]->getShadowObject());
            return;
        }
        osg::ref_ptr<JSONObject> json = new JSONNode;
        applyCommonMatrixTransform("osgAnimation.Bone", json, node, parent);

        json->getMaps()["InvBindMatrixInSkeletonSpace"] = new JSONMatrix(node.getInvBindMatrixInSkeletonSpace());
        //json->getMaps()["MatrixInSkeletonSpace"] = new JSONMatrix(node.getMatrixInSkeletonSpace());

        osg::Vec3 min, max;
        if(node.getUserValue("AABBonBone_min", min) && node.getUserValue("AABBonBone_max", max)) {
            JSONObject *obj = new JSONObject;
            obj->getMaps()["min"] = new JSONVec3Array(min);
            obj->getMaps()["max"] = new JSONVec3Array(max);

            json->getMaps()["AABBonBone"] = obj;
        }

        _parents.push_back(json);
        traverse(node);
        _parents.pop_back();
    }

    void apply(osg::PositionAttitudeTransform& node)
    {
        JSONObject* parent = getParent();
        if (_maps.find(&node) != _maps.end()) {
            parent->addChild("osg.MatrixTransform", _maps[&node]->getShadowObject());
            return;
        }

        osg::ref_ptr<JSONObject> json = new JSONNode;
        json->addUniqueID();
        _maps[&node] = json;

        applyCallback(node, json.get());
        createJSONStateSet(node, json.get());

        parent->addChild("osg.MatrixTransform", json.get());

        initJsonObjectFromNode(node, *json);
        osg::Matrix matrix = osg::Matrix::identity();
        node.computeLocalToWorldMatrix(matrix,0);
        json->getMaps()["Matrix"] = new JSONMatrix(matrix);
        _parents.push_back(json);
        traverse(node);
        _parents.pop_back();
    }

    void setBaseName(const std::string& basename) { _baseName = basename; }
    void useExternalBinaryArray(bool use) { _useExternalBinaryArray = use; }
    void mergeAllBinaryFiles(bool use) { _mergeAllBinaryFiles = use; }
    void inlineImages(bool use) { _inlineImages = use; }
    void setVarint(bool use) { _varint = use; }
    void setMaxTextureDimension(int use) { _maxTextureDimension = use; }
    void addSpecificBuffer(const std::string& bufferFlag) {
        std::string key, value;
        unsigned int colon = bufferFlag.find(":");
        if(colon != std::string::npos) {
            key = bufferFlag.substr(0, colon);
            value = bufferFlag.substr(colon + 1, std::string::npos);
        }
        else {
            key = value = bufferFlag;
        }
        _specificBuffers[key] = value;
    }
};

#endif
